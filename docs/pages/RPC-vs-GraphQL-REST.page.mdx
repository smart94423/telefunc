import { Link } from 'libframe-docs/components'

WORK-IN-PROGRESS

> We explain what RPC is at <Link href="/tour"/>.

## RPC ➡️ coupling

RPC induces a tight coupling between our frontend and our Node.js server.

~~~js
// TodoList.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

// This telefunction is tightly coupled to the frontend: it returns exactly and
// only what the <TodoList /> component needs.

export async function getInitialData() {
  const { user } = getContext()
  if (!user) {
    return { isNotLoggedIn: true }
  }
  const todoItems = await database.query(
    'SELECT id, text FROM todos WHERE authorId = :authorId',
    { authorId: user.id }
  )
  const { firstName } = user
  return {
    user: { firstName },
    todoItems
  }
}
~~~

If we change our `<TodoList>` component to also show the to-do items's creation date,
then we need to change the SQL query of our `getInitialData()` telefunction from `SELECT id, text` to `SELECT id, text, created_at`.

This means that the frontend development/developers need to be able make changes to the Node.js server and re-deploy it.

> We can still have a decoupled frontend-backend development by using a dedicated Telefunc server:
> a Node.js server with sole purpose of serving telefunctions.
>
> The frontend develops and deploys the Telefunc server hand-in-hand, while the backend (another Node.js server, Ruby on Rails, ...) can be developed independently.


## GraphQL/REST ➡️ decoupling

In contrast to telefunctions (RPC endpoints), which are tailored to the need of the frontend, a GraphQL/RESTful API is generic:
the API endpoints are always designed to be able to fulfill a maximum number of data requirements.

> That's why GraphQL is so popular: GraphQL queries can achieve much more than REST queries

This means GraphQL and REST enables us to develop and deploy the backend once,
and then develop frontend using the GraphQL/RESTful API while the backend is set- in stone. of the backend.

In other words: a GraphQL/RESTful API decouples the frontend from the backend.


without the need of changing/re-deploying the backend.


## Which one to choose?

RPC enables our frontend to directly use ORM/SQL queries which is not only a fundamentally simpler approach,
but also more powerful (we can achieve more with ORM/SQL queries than with GraphQL/RESTful queries).

GraphQL/RESTful on the other hands enables a decoupling between frontend and backend.

This means that if don't need a decoupled frontend-backend then we should choose RPC.

So the question here is: when do we need a decoupled frontend-backend?

**Third parties**

The most relevant use case for REST and GraphQL is to create an API that is meant to be used by third-party developers.

Third parties that access our databases develop their frontend/clients independently of our backend and we therefore cannot use RPC as it couples frontend with .

Facebook's API, for example, is used by ~200k third parties. It is no surprise that Facebook invented and uses GraphQL; it enables third-party developers to extensively access Facebook's social graph allowing them to build all kinds of applications.

For an API used by many third parties with many diverse uses cases, GraphQL and REST are the only options and GraphQL is especially a good fit. to a lesser extent) is the right tool.

**Large companies**

Large companies with highly complex databases may not want to directly expose the database to the entire company;
instead, exposing a internal GraphQL/REST API may be a sensible choice as it enables database owners and application developer to work independently of each other.

Note that having many different applications developed by the company is *not* a reason to use a GraphQL/REST API:
each application can maintain and deploy a separate Node.js server with a different set of telefunctions.

**In a nutshell**

GraphQL and REST represet an indirection that is limiting and time consuming.
Properly setting up a GraphQL API is a complex and error-prone task, especially at scale.

So we should use GraphQL and REST only if we have a good reason to;
RPC should be our default choice.

A sensible strategy is to start with RPC and to migrate to GraphQL/REST if and only if the need arises.

If we develop backend and frontend hand-in-hand,
then
makes it possible to use RPC which is fundamentally simpler and more powerful.
, wich is an increasingly ubiquitous practice with full-stack frameworks such as Next.js and Vike,


** Conclusion **


That said, if we need a decoupling between frontend and backend, then RPC is not an option and we have to use GraphQL/REST.

So we should use RPC whenever we can.


So really the question is not which one "better", but really more about which one we can use.

If we can use RPC then we should use it as it enables a drastically higher development speed.
This means that RPC we can develop our app at much higher speed.
RPC enables we can usually develop our app

## Decoupled backend-frontend deployments

## Mobile Apps



## Conclusion

However, if you want to create a backend API that is meant to be consumed only by your frontend, then you don't need REST nor GraphQL — RPC, such as Wildcard, is enough.

For a large app, you may still want the structure that comes with a RESTful/GraphQL API. But this typically applies only for large companies that develop apps with a large number of developers. "Premature optimization is the root of all evil"; start with RPC as default and later switch to REST or GraphQL when (and only if!) the need arises.

In a nuthsell:
 - Is your API meant to be used by third parties? Use REST or GraphQL.
 - Is your API meant to be used by yourself? Use Telefunc/RPC.

In a nutshell: we should use RPC whenever we can.

So the question here is whether we can use RPC or not.

