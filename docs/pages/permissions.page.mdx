import { Link, ReadingRecommendation } from 'libframe-docs/components'

<ReadingRecommendation links={['/tour', '/abort-shield', '/auth']} />

> **TL;DR**
>
> With Telefunc, we define permissions programmatically by using cancel mechanisms:
>  - `throw Abort()`
>  - `return someValue`
>  - `throw Abort(someValue)`
>
> We can implement `getContext()` wrappers for:
>  - Advanced permission rules.
>  - Increased safety.

## `throw Abort()`

We can use `throw Abort()` to ensure permissions.

```js
// Comment.telefunc.js
// Environment: Node.js

import { getContext, Abort, shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getContext()

  // Only admins are allowed to delete comments
  if (!user.isAdmin) {
    throw Abort()
  }

  // ...
}
```

> We use `throw Abort()` even if we know our frontend to always call `onCommentDelete()` with the right permissions. See:
> - <Link href="/abort-shield#random-telefunction-calls" />

We can also cancel a telefunction call with `return someValue`.


## `return someValue`

If, upon wrong permissions, we want to pass information to the frontend we can use `return someValue`.

```js
// components/TodoList.telefunc.js
// Environment: Node.js

export { getTodoList }

import { getContext } from 'telefunc'

async function getTodoList() {
  const { user } = getContext()

  if (!user) {
    // It is expected that the user may not be logged in. We `return { isNotLoggedIn: true }`
    // instead of `throw Abort()`, so that the frontend can redirect the user to the login page.
    return { isNotLoggedIn: true }
  }

  // ...
}
```

```js
// components/TodoList.js
// Environment: Browser

import { getTodoList } from './TodoList.telefunc.js'

async function someFrontendFunction() {
  // ...
  const result = await getTodoList()
  if (result.isNotLoggedIn) {
    // Redirect user to login page
    window.location.href = '/login'
  }
  // ...
}
```

## `throw Abort(someValue)`

Alternatively to `return someValue`, we can use `throw Abort(someValue)` which can be more convenient, for example when defining global behavior.

```js
// auth/getUser.ts
// Environment: Node.js

// Note that `auth/getUser.ts` is not a `.telefunc.js` file and `getUser()` not a telefunction
export { getUser }

import { getContext, Abort } from 'telefunc'

// Such `getContext()` wrapper is a common Telefunc technique
function getUser() {
  const { user } = getContext()
  if (!user) {
    throw Abort({ isNotLoggedIn: true })
  }
  return user
}
```
```js
// Environment: Browser

import { onTelefunctionRemoteCallError } from 'telefunc/client'

onTelefunctionRemoteCallError(err => {
  if (err.isAbort && err.abortValue.isNotLoggedIn) {
    // Redirect user to login page
    window.location.href = '/login'
  }
})
```

We have globally defined what should happen when a user is not logged-in;
we don't have to re-implement the same logic over and over again.

```js
// components/TodoList.telefunc.js
// Environment: Node.js

export { getTodoList }

import { getUser } from '../auth/getUser'

async function getTodoList() {
  const { user } = getUser()
  // We don't have to handle the not-logged-in case here anymore.
  // We can safely assume the user to be logged-in here.
  const todoList = await Todo.findMany({ authorId: user.id })
  return todoList
}
```
```js
// components/TodoList.js
// Environment: Browser

import { getTodoList } from './TodoList.telefunc.js'

async function someFrontendFunction() {
  // ...
  const todoList = await getTodoList()
  // We can safely assume `todoList` to be defined
  todoList.forEach(todoItem => {
    document.querySelector('#view').innerHTML += '<p>To-Do: ' + todoItem.text + '</p>'
  })
  // ...
}
```


## `getContext()` wrappers

Implementing `getContext()` wrappers is a convenient way
to solidify permissions.

```js
// components/Comment.telefunc.js
// Environment: Node.js

import { getUser } from '../auth/getUser'
import { shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getUser({ permission: 'admin' })
  const comment = await Comment.findOne({ id })
  await comment.delete()
}
```

```js
// auth/getUser.ts
// Environment: Node.js

// Note that `auth/getUser.ts` is not a `.telefunc.js` file and `getUser()` not a telefunction
export { getUser }

import { Abort, getContext } from 'telefunc'

function getUser({ permission }) {
  const { user } = getContext()
  if (!user) {
    throw Abort()
  }
  if (permission === 'admin') {
    if (!user.isAdmin) throw Abort()
    return user
  }
  if (permission === 'public') {
    return user
  }
  // ...
}
```

We can even go deeper and wrap ORM/SQL queries.

```js
// components/TodoList.telefunc.js
// Environment: Node.js

import { findTodoItem } from '../database/todo/findTodoItem'
import { shield } from 'telefunc'

shield(onTextChange, [{ text: shield.type.string }])
export async function onTextChange({ id, text }) {
  // Only the author of a to-do item is allowed to change its text
  const todoItem = await findTodoItem({ id }, { permission: 'author' })
  todoItem.text = text
  await todoItem.save()
}
```
```js
// database/todo/findTodoItem.js

export { findTodoItem }

import { getContext, Abort } from 'telefunc'

async function findTodoItem(props, { permission }) {
  // For increased safety, we ensure that a `permission` is always provided.
  if (!permission) {
    throw new Error('Wrong findTodoItem() usage: missing permission')
  }
  // For increased safety, we make sure there are no typos.
  if (!['public', 'author', 'admin'].includes(permission)) {
    throw new Error('Wrong findTodoItem() usage: unknown permission ' + permission)
  }

  const { user } = getContext()

  const todoItem = await Todo.findOne({ where: props })

  if (permission === 'admin') {
    // Only admins are allowed to access `todoItem`
    if (!user.isAdmin) throw Abort()
    return todoItem
  }

  if (permission === 'author') {
    // Only the author of `todoItem` is allowed to access it
    if (todoItem.authorId !== user?.id) throw Abort()
    return todoItem
  }

  if (permission === 'public') {
    // Everyone is allowed to access `todoItem`
    return todoItem
  }
}
```

> In case you are wondering: we don't use `throw Abort()` but `throw new Error()` in ``throw new Error('Wrong findTodoItem() usage')`` because `findTodoItems()` is an internal function and not a public telefunction, see <Link href='/abort-or-error' />.
