import { Link, ReadingRecommendation } from 'libframe-docs/components'

<ReadingRecommendation links={['/tour', '/tour#telefunctions-need-protection', '/abort-shield', '/auth']} />

With Telefunc, we define permissions programmatically by using a cancel mechanism:
 - `throw Abort()`
 - `return someValue`
 - `throw Abort(someValue)`

We can implement `getContext()` wrappers to implement:
 - Advanced permissions.
 - Increased safety.

## `throw Abort()`

We can `throw Abort()` to ensure our telefunctions to be called with the right permissions.

```js
// Comment.telefunc.js
// Environment: Node.js

import { getContext, Abort, shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getContext()

  // Only admins are allowed to delete comments
  if (!user.isAdmin) {
    throw Abort()
  }

  // ...
}
```

> We should `Abort()` even if we know our frontend to always call `onCommentDelete()` with the right permissions (for example because our UI displays the `<DeleteCommentButton />` components only to admins). See:
> - <Link href="/abort-shield#always-abort" />


## `return someValue`

Sometimes, it is expected that our frontend can call our telefunction with wrong permissions.

```js
// TodoList.telefunc.js
// Environment: Node.js

export { getTodoList }

import { getContext } from 'telefunc'

async function getTodoList() {
  const { user } = getContext()

  if (!user) {
    // It is expected that the user may not be logged in. We `return { isNotLoggedIn: true }`
    // instead of `throw Abort()`, so that the frontend can redirect the user to the login page.
    return { isNotLoggedIn: true }
  }

  // ...
}
```

In contrast to our previous telefunction `onCommentDelete()`,
here we expect our frontend to sometimes call `getTodoList()` with the wrong permission.

If we need to pass information to the frontend,
we can `return someValue` instead of `throw Abort()`.

But we can also `throw Abort(someValue)`.

## `throw Abort(someValue)`

As we have seen in the previous section, when wrong permissions are expected, we use `return someValue`.

But `return someValue` can become cumbersome.

```js
// auth/getUser.ts

import { getContext } from 'telefunc'

// It is a common technique to provide convenience `getContext()` wrappers
export { getUser }

function getUser() {
  const { user } = getContext()
  return user
}
```

```js
// components/TodoList.telefunc.js
// Environment: Node.js

export { fetchTodoList }

import { getUser } from '../auth/getUser'

async function fetchTodoList() {
  const { user } = getUser()

  if (!user) {
    return { isNotLoggedIn: true }
  }

  // ...
}

async function onNewTodo() {
  const { user } = getUser()

  // We have to implement our logic over and over again
  if (!user) {
    return { isNotLoggedIn: true }
  }

  // ...
}
```

We also that on the frontend we always need wrap all our telefunctions:

```js


```

That's not ideal.

Instead, by using `throw Abort(someValue)` with `onTelefunctionRemoteCallError()`, we can implement our logic only once.

```js
// auth/getUser.ts

import { Abort, getContext } from 'telefunc'

// It is a common technique to provide convenience wrappers around `getContext()`
export { getUser }

function getUser() {
  const { user } = getContext()
  if (!user) {
    throw Abort({ isNotLoggedIn: true })
  }
  return user
}
```

```
// Browser

import { onTelefunctionRemoteCallError } from 'telefunc/client'

onTelefunctionRemoteCallError(err => {
  if (err.isAbort && err.abortValue.isNotLoggedIn) {
    // Redirect user to login page
    window.location.href = '/login'
  }
})
```

> This is the 

## `getContext()` wrappers

```js
// auth/getUser.ts

// Note how `auth/getUser.ts` is not a `.teleunc.js` file.

import { Abort, getContext } from 'telefunc'

// It is a common technique to provide convenience wrappers around `getContext()`
export { getUser }

function getUser({ permissions, databaseObject }) {

  // `databaseObject` could for example

  const { user } = getContext()
  if (!user) {
    throw Abort({ isNotLoggedIn: true })
  }
  permissions.forEach(
  return user
}
```

We can also provide wrappers around `getContext()` and ORM/SQL queries to achieve:
 - 

```js
// database/mutate.js

// Note how `auth/getUser.ts` is not a `.teleunc.js` file.

export { mutate }

import { Abort, getContext } from 'telefunc'

async function findObject(objectProps, permissions) {
  // For increased safety, we ensure that a `permissions` array is always provided
  // when accessing the database.
  if (!permissions) {
    throw new Error('Wrong `findObject()` usage: missing permissions array')
  }

  // For increased safety, we make sure there are no typos
  permissions.forEach(permission => {
    if (!['public', 'author', 'admin'].includes(permission)) {
      throw new Error('Wrong `findObject()` usage: unkown permission ' + permission)
    }
  })

  const { user } = getContext()

  const object = await database.findOject(objectProps)

  if (permissions.includes('admin')) {
    if (!user?.isAdmin) {
      throw Abort()
    }
    // Admins are allowed to access `object`
    return object
  }

  if (permissions.includes('author')) {
    if (object.authorId !== user?.id) {
      throw Abort()
    }
    // The author of `object` is allowed to access it
    return object
  }

  if( permissions.includes('public') ) {
    // Everyone is allowed to access `object`
    return object
  }

  throw new Error('Wrong `findObject()` usage: make sure to define at least one permission')
}
```

> The **difference between `throw Abort()` and `throw new Error()`** is explained at 


