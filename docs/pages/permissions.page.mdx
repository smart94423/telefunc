import { Link, ReadingRecommendation } from 'libframe-docs/components'

<ReadingRecommendation links={['/tour', '/tour#telefunctions-need-protection', '/abort-shield']} />

There are three methods to implement permissions:
 1. `throw Abort()`
 1. `return someValue`
 1. `throw Abort(someValue)`


## `throw Abort()`

We can `throw Abort()` to ensure our telefunctions to be called with the right permissions.

```js
// Comment.telefunc.js
// Environment: Node.js

import { getContext, Abort, shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getContext()

  // Only admins are allowed to delete comments
  if (!user.isAdmin) {
    throw Abort()
  }

  // ...
}
```

> We always use `Abort()` here, even if we know that our frontend uses `onCommentDelete()` always with the right permissions (for example because our UI displays the `<DeleteCommentButton />` components only to admins). See:
> - <Link href="/abort-shield#always-abort" />


## `return someValue`

Sometimes, it is expected that our frontend may call our telefunction with wrong permissions.

```js
// *.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

export async function getTodoList() {
  const { user } = getContext()

  if (!user) {
    // It is expected that the user may not be logged in. We `return { isNotLoggedIn: true }`
    // instead of `throw Abort()`, so that the frontend can redirect the user to the login page.
    return { isNotLoggedIn: true }
  }

  // ...
}
```

## `throw Abort(someValue)`

As we have seen in the previous section, when wrong permissions are expected, we use `return someValue`.

But `return someValue` can become cumbersome.

```js
// auth/getUser.ts

import { getContext } from 'telefunc'

// It is a common technique to provide convenience `getContext()` wrappers
export { getUser }

function getUser() {
  const { user } = getContext()
  return user
}
```

```js
// components/TodoList.telefunc.js
// Environment: Node.js

export { fetchTodoList }

import { getUser } from '../auth/getUser'

async function fetchTodoList() {
  const { user } = getUser()

  if (!user) {
    return { isNotLoggedIn: true }
  }

  // ...
}

async function onNewTodo() {
  const { user } = getUser()

  // We have to implement our logic over and over again
  if (!user) {
    return { isNotLoggedIn: true }
  }

  // ...
}
```

We also that on the frontend we always need wrap all our telefunctions:

```js


```

That's not ideal.

Instead, by using `throw Abort(someValue)` with `onTelefunctionRemoteCallError()`, we can implement our logic only once.

```js
// auth/getUser.ts

import { Abort, getContext } from 'telefunc'

// It is a common technique to provide convenience wrappers around `getContext()`
export { getUser }

function getUser() {
  const { user } = getContext()
  if (!user) {
    throw Abort({ isNotLoggedIn: true })
  }
  return user
}
```

```
// Browser

import { onTelefunctionRemoteCallError } from 'telefunc/client'

onTelefunctionRemoteCallError(err => {
  if (err.isAbort && err.abortValue.isNotLoggedIn) {
    // Redirect user to login page
    window.location.href = '/login'
  }
})
```

> This is the 

## `getContext()` wrappers

```js
// auth/getUser.ts

import { Abort, getContext } from 'telefunc'

// It is a common technique to provide convenience wrappers around `getContext()`
export { getUser }

function getUser(permissions) {
  const { user } = getContext()
  if (!user) {
    throw Abort({ isNotLoggedIn: true })
  }
  permissions.forEach(
  return user
}
```






## `Abort()`

We use `Abort()` to ensure permissions:

```js
// Comment.telefunc.js
// Environment: Node.js

import { getContext, Abort, shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getContext()

  // Only admins are allowed to delete comments
  if (!user.isAdmin) {
    throw Abort()
  }

  // ...
}
```

We use `Abort()` even if we know that our frontend calls telefunction always with the right permissions.

```jsx
// Comment.jsx
// Environment: Browser

import { onCommentDelete } from './Comment.telefunc.js'

function Comment({ id, text, context }) {
  const deleteButton =
    // Note how we only show the delete button to admins
    context.user.isAdmin ?
      <button onClick={() => onCommentDelete(id)}>Delete</button> :
      null
  return <>
    <p>{ text }</p>
    { deleteButton }
  </>
}
```

Because the delete button is only shown to admins,
whenever our frontend calls `onCommentDelete()`
we can assume the user to be an admin.

But we still use `Abort()`:
as we have seen in the <Link text="Telefunc Tour" href="/tour" />,
our telefunctions can be called not only by our frontend but really by anyone.
A malicious user can call `onCommentDelete()` without admin priviledges;
but thanks to our `throw Abort()` the call is aborted.

In other words, we use `Abort()` to protect against unexpected calls (calls not originating from our frontend, or if our frontend has a bug).


## `return`

If it is expected that our frontend calls telefunctions sometimes without the right permissions,
we `return` instead of `throw Abort()`.

```js
// *.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

export async function getTodoList() {
  const { user } = getContext()

  if (!user) {
    // It is expected that the user may not be logged in. We `return { isNotLoggedIn: true }`
    // instead of `throw Abort()`, so that the frontend can redirect the user to the login page.
    return { isNotLoggedIn: true }
  }

  // ...
}
```

In contrast to our previous telefunction `onCommentDelete()`,
here we expect our frontend to sometimes call `getTodoList()` with the wrong permission.

If we need to pass information to the frontend,
we `return` instead of `throw Abort()`.


## `shield()`

Ensuring argument types with `throw Abort()` can be cumbersome:

```js
// CreateTodo.telefunc.js
// Environment: Node.js

export async function onNewTodo(args) {
  if (
    args?.constructor !== Object ||
    typeof args.text !== 'string' ||
    typeof args.isCompleted !== 'boolean'
  ) {
    throw Abort()
  }
  const { text, isCompleted } = args
  /* ... */
}
```

For more convenience we can use `shield()` instead:

```js
// CreateTodo.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

shield(onNewTodo, [{ text: t.string, isCompleted: t.boolean }])
export async function onNewTodo({ text, isCompleted }) {
  // ...
}
```

Not only does `shield()` call `throw Abort()` on our behalf, but it also infers the arguments' type for IntelliSense and TypeScript.

More infos at <Link href="/shield" />.


## Form validation

It is expected that the user can enter invalid inputs; we `return` instead of `throw Abort()`.

```js
// *.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'

shield(onFormSubmit, [email: t.string, password: t.string])
export async function onFormSubmit(email, password) {
  const invalidInputs = {}

  if (!email) {
    invalidInputs.email = 'Please enter your email.'
  } else if (!email.includes('@')) {
    invalidInputs.email = 'Invalid email; make sure to enter a valid email.'
  }

  if (Object.keys(invalidInputs).length > 0) {
    return { invalidInputs }
  }

  // ...
}
```
