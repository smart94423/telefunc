import { Link, ReadingRecommendation } from 'libframe-docs/components'

<ReadingRecommendation links={['/tour', '/abort-shield']} />

> **TL;DR**
>
> With Telefunc, we define permissions programmatically by using a cancel mechanism:
>  - `throw Abort()`
>  - `return someValue`
>  - `throw Abort(someValue)`
>
> We can implement `getContext()` wrappers for:
>  - Advanced permissions.
>  - Increased safety.

## `throw Abort()`

If a permission is not respected then we cancel the telefuction call, for example with `throw Abort()`.

We can `throw Abort()` to ensure our telefunctions to be called with the right permissions.

```js
// Comment.telefunc.js
// Environment: Node.js

import { getContext, Abort, shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getContext()

  // Only admins are allowed to delete comments
  if (!user.isAdmin) {
    throw Abort()
  }

  // ...
}
```

> We should `Abort()` even if we know our frontend to always call `onCommentDelete()` with the right permissions (for example because our UI displays the `<DeleteCommentButton />` components only to admins). See:
> - <Link href="/abort-shield#random-telefunction-calls" />

But we can also cancel a telefunction with `return someValue`.

## `return someValue`

If, upon wrong permissions, we want to pass information to the frontend we can `return someValue`:

```js
// components/TodoList.telefunc.js
// Environment: Node.js

export { getTodoList }

import { getContext } from 'telefunc'

async function getTodoList() {
  const { user } = getContext()

  if (!user) {
    // It is expected that the user may not be logged in. We `return { isNotLoggedIn: true }`
    // instead of `throw Abort()`, so that the frontend can redirect the user to the login page.
    return { isNotLoggedIn: true }
  }

  // ...
}
```

```js
// components/TodoList.js
// Browser

import { getTodoList } from './TodoList.telefunc.js'

  // ...

  const result = await getTodoList()

  if (result.isNotLoggedIn) {
    // Redirect to login page
    window.location.href = '/login'
  }

  // ...
```

## `throw Abort(someValue)`

Alternatively to `return someValue`, we can `throw Abort(someValue)` which can be more convenient, for example when defining global behavior.

```js
// auth/getUser.ts
// Environment: Node.js

// Note that `auth/getUser.ts` is not a `.telefunc.js` file.
// Such `getContext()` convenience wrapper is a common Telefunc technique.
export { getUser }

import { Abort, getContext } from 'telefunc'

function getUser() {
  const { user } = getContext()
  if (!user) {
    throw Abort({ isNotLoggedIn: true })
  }
  return user
}
```
```js
// Browser

import { onTelefunctionRemoteCallError } from 'telefunc/client'

onTelefunctionRemoteCallError(err => {
  if (err.isAbort && err.abortValue.isNotLoggedIn) {
    // Redirect to login page
    window.location.href = '/login'
  }
})
```

```js
// components/TodoList.telefunc.js
// Environment: Node.js

export { getTodoList }

import { getUser } from '../auth/getUser'

async function getTodoList() {
  const { user } = getUser()

  // We don't have to handle the not-logged-in case here anymore

  // We can safely assume `user` to be defined
  const todoList = await Todo.findMany({ authorId: user.id })
  return todoList
}
```

```js
// components/TodoList.js
// Browser

import { getTodoList } from './TodoList.telefunc.js'

  // ...

  const todoList = await getTodoList()

  // Here we can as well safely assume `todoList` to be defined
  todoList.forEach(todoItem => {
    document.querySelector('#view').innerHTML += '<p>To-Do: ' + todoItem.text + '</p>'
  })

  // ...
```


## `getContext()` wrappers

Implementing `getContext()` wrappers is a convenient way
to solidify permissions.

```js
// components/Comment.telefunc.js
// Environment: Node.js

import { getContext, Abort, shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getUser({ permission: 'admin' })
  const comment = await Comment.findOne({ id })
  await comment.delete()
}
```

```js
// auth/getUser.ts
// Environment: Node.js

// Note that `auth/getUser.ts` is not a `.telefunc.js` file.
export { getUser }

import { Abort, getContext } from 'telefunc'

function getUser({ permission }) {
  const { user } = getContext()

  if (!user) {
    // We provide .. TODO
    throw Abort({ isNotLoggedIn: true })
  }

  if (permission === 'admin') {
    if (!user?.isAdmin) {
      throw Abort()
    }
    return user
  }

  if (permission === 'public') {
    return user
  }

  // ...
}
```

We can also provide ORM/SQL query wrappers.

```js
// components/TodoList.telefunc.js
// Environment: Node.js

export { onTextChange }

import { findTodoItem } from '../database/todo/findTodoItem'
import { shield } from 'telefunc'
const t = shield.type

shield(onTextChange, [{ text: t.string }])
async function onTextChange({ id, text }) {
  const todoItem = await findTodoItem({ id }, { permission: 'author' })
  todoItem.text = text
  await todoItem.save()
}
```
```js
// database/todo/findTodoItem.js

export { findTodoItem }

import { Abort, getContext } from 'telefunc'

async function findTodoItem(props, { permission }) {
  // For increased safety, we ensure that a `permission` is always provided
  // when accessing the database.
  if (!permissions) {
    throw new Error('Wrong `findTodoItem()` usage: missing permission')
  }

  // For increased safety, we make sure there are no typos
  if (!['public', 'author', 'admin'].includes(permission)) {
    throw new Error('Wrong `findTodoItem()` usage: unknown permission ' + permission)
  }

  const { user } = getContext()

  const todoItem = await Todo.findOne({ where: props })

  if (permission === 'admin') {
    if (!user?.isAdmin) {
      throw Abort()
    }
    // Admins are allowed to access any to-do item
    return todoItem
  }

  if (permission === 'author') {
    if (todoItem.authorId !== user?.id) {
      throw Abort()
    }
    // The author of `todoItem` is allowed to access it
    return todoItem
  }

  if (permission === 'public') {
    // Everyone is allowed to access `todoItem`
    return todoItem
  }
}
```

> In case you are wondering: we use `new Error()` in `throw new Error('Wrong `findTodoItem()` usage')` because `findTodoItems()` is an internal function and not a public telefunction, see
> <Link href='/abort-or-error' />
