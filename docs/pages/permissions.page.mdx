import { Link } from 'libframe-docs/components'

> We recommend taking the <Link text="Telefunc Tour" href="/tour" /> before reading this document.

We ensure permissions by using either `throw Abort()` or `return`.

```js
async function someTelefunction() {
  if (someCondition) {
    throw new Abort()
  }
}
```

```js
async function someTelefunction() {
  if (someCondition) {
    return someValue
  }
}
```

## With `Abort()`

We can use `throw Abort()` to ensure permissions:

```js
// Comment.telefunc.js
// Environment: Node.js

import { getContext, Abort, shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getContext()

  // We ensure that the user is an admin
  if( !user?.isAdmin ) {
    throw Abort()
  }

  // ...
}
```

We use `Abort()`
the frontend
Let's see why with following example

We use `Abort()` because we assume the frontend to never 

Let's consider this frontend.
With following frontend:

```jsx
// Comment.jsx
// Environment: Browser

import { onCommentDelete } from './Comment.telefunc.js'

function Comment({ id, text, context }) {
  const deleteButton = <button onClick={() => onCommentDelete(id)}>Delete</button>
  return <>
    <p>{ text }</p>
    {
      // We only show the delete button to admins
      !context.user.isAdmin ?  deleteButton : null
    }
  </>
}
```

Because the delete button is only shown to admins,
when our frontend calls `onCommentDelete()`,
we can assume the user to be an admin.

If we can assume the user to be an admin, we may wonder why do we need to `throw Abort()` then?

If our `onCommentDelete()` is only called from our frontend, then we could actually skip our `throw Abort()` condition.

But,
as we have seen in the <Link text="Telefunc Tour" href="/tour" />,
our `onCommentDelete()` telefunction can be called not only by our frontend but really by anyone
and that's why we need to use `throw Abort()`:
it could be that a malicious user without admin priviledges tries to call `onCommentDelete()` our `throw Abort()` condition ensures that this doesn't happen.

it ensures that, not matter who calls `onCommentDelete()` the user is an admin.

To sum up: if our `onCommentDelete()` telefunction is always called by our frontend, and our app is bug-free,
then we our `Abort()` is never called.

In a nutshell: `Abort()` protects our telefunctions from *unwanted* calls.

For situations, we can simply `return` a value.
There are situations when we actualy want

As we have seen in the <Link text="Telefunc Tour" href="/tour" />,
`shield()`
We can assume, there is a bug-free or is called by another client than our frontend.
We can 
For the same reason 

## With `return`

We can also `return` instead of `throw Abort()`.

```js
// *.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

export async function getTodoList() {
  const { user } = getContext()

  if (!user) {
    // It is expected that the user may not be logged-in. We `return { isNotLoggedIn: true }`
    // instead of `throw Abort()` so that the frontend can redirect the user to the login page.
    return { isNotLoggedIn : true }
  }

  // ...
}
```

In contrast to our previous telefunction `onCommentDelete()`,
here we expect our frontend to sometimes call `getTodoList()` without the right permissions;
we then `return` the information that the user is not logged-in to the frontend,
so that the frontend can react accordingly.

In general, if we want to pass information to the frontend, we `return` instead of `throw Abort()`.


## Form Validation

It is expected that the user form validation and the frontend needs to report back to the user what went wrong; we `return` instead of `throw Abort()`.

```js
import { shield } from 'telefunc'

shield(onFormSubmit, [{ email: t.string }])
export async function onFormSubmit({ email }) {
  const formValidationErrors = {}
  if (!email) {
    formValidationErrors.firstName = 'Please enter your email.'
  } else if(!email.includes('@')) {
    formValidationErrors.firstName = 'Invalid email; make sure to enter a valid email.'
  }
  if (Object.keys(formValidationErrors).length > 0) {
    return formValidationErrors
  }
  // ...
}
```


## Which one to use?

The general idea here is that `throw Abort()` represents something unexpected:
if one of our telefunction is called by our frontend
if our app is bug-free then
`throw Abort()` is never called if:
 - our app is bug-free, and
 - no third party is trying to call our telefunctions. (Our [telefunctions are public]())

As we have seen in the Telefunc Tour, our telefunctions are public and thus any third party cann

For example, in the `deleteComment()` telefunction above,
we can assume our frontend to never call `deleteComment()` for a user that is not an admin.

That said, in doubt,
we can use whatever works for us.

There are situations where we don't want to `Abort()` upon wrong permissions. For example:

~~~js
~~~

There is a bug

Telefunc doesn't provide any exception other than `Abort()`, and `Abort()` doesn't accept any argument;
if 
Because for fine-grain control we simply return JavaScript values instead,
which is more readable (we can see what simply by reading),
less error-prone 
This is 

We either `throw Abort()` or `return someValue`.




> Behind the scenes, `shield()` calls `Abort()`







Note how `shield()` and `Abort()` work well together.

```js
// onNewTodo.telefunc.js
// Environment: Node.js

import { shield, getContext } from 'telefunc'

// We use `shield()` to ensure arugments types.
shield(onNewTodo, [shield.type.string])
export async function onNewTodo(text) {
  const { user } = getContext()

  // We use `Abort()` to, essentially, define permissions.
  if( user === null ) {
     // Only authenticated users can create a new to-do.
     throw Abort()
  }

  /* ... */
}
```



> Note that we still use `shield()` which will `throw Abort()`

