import { Link, ReadingRecommendation } from 'libframe-docs/components'

<ReadingRecommendation links={['/tour']} />

As <Link text="we have seen in the tour" href="/tour#telefunctions-need-protection" />, telefunctions are public and need protection.

We protect telefunctions by using `throw Abort()`, `shield()` and `return someValue`.

## `throw Abort()`

We can `throw Abort()` to protect our telefunctions:

```js
// TodoList.telefunc.js
// Environment: Node.js

export { getTodoList }

import { getContext } from 'telefunc'

async function getTodoList() {
  const { user } = getContext()

  if (!user) {
    throw Abort()
  }

  const todoList = await Todo.findMany({ authorId: user.id })
  return todoList
}
```

> Here, in essence, we use `throw Abort()` to implement a permission: only a logged-in user can fetch its to-do items.
> We talk more about permissions at <Link href="/permissions" />.

> In principle, we could also `throw new Error()` instead of `throw Abort()` (both achieve the job of canceling the telefunction call), but `Abort()` comes with convenient and is semantically correct features and we recommend to use `throw Abort()`.

## Random telefunction calls

We can assume our frontend to always call our telefunctions in a certain way,
but because <Link text="telefunctions are public" href="/tour#telefunctions-need-protection" />,
anyone can call our telefunctions with any argument.

One way to think about it is that any random telefunction call can happen at any time.

This means we should always protect our telefunctions, regardless of our Frontend.

We use `Abort()` even if we know that our frontend calls telefunction always with the right permissions.

For example:

```js
// Comment.telefunc.js
// Environment: Node.js

import { getContext, Abort, shield } from 'telefunc'

shield(onCommentDelete, [shield.type.number])
export async function onCommentDelete(id) {
  const { user } = getContext()

  // Only admins are allowed to delete comments
  if (!user.isAdmin) {
    throw Abort()
  }

  // ...
}
```

```jsx
// Comment.jsx
// Environment: Browser

import { onCommentDelete } from './Comment.telefunc.js'

function Comment({ id, text, context }) {
  const deleteButton =
    // Note how we only show the delete button to admins
    context.user.isAdmin ?
      <button onClick={() => onCommentDelete(id)}>Delete</button> :
      null
  return <>
    <p>{ text }</p>
    { deleteButton }
  </>
}
```

Because the delete button is only shown to admins,
whenever our frontend calls `onCommentDelete()`
we can assume the user to be an admin.

But we still use `Abort()`:
`onCommentDelete()` can be randomly called with any random arguments by anone at anytime.

In this situation, we basically use `Abort()` to protect against calls not originating from our frontend.

## `shield()`

We can also use `Abort()` to ensure the type of Telefunction arguments.

```js
// CreateTodo.telefunc.js
// Environment: Node.js

export async function onNewTodo(args) {
  if (
    args?.constructor !== Object ||
    typeof args.text !== 'string' ||
    typeof args.isCompleted !== 'boolean'
  ) {
    throw Abort()
  }
  const { text, isCompleted } = args
  /* ... */
}
```

But this is inconvenient and we can use `shield()` instead:

```js
// CreateTodo.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

shield(onNewTodo, [{ text: t.string, isCompleted: t.boolean }])
export async function onNewTodo({ text, isCompleted }) {
  // ...
}
```

Not only does `shield()` call `throw Abort()` on our behalf but it also infers the arguments' type for IntelliSense and TypeScript.

See also:
 - <Link href="/typescript#shield" />
 - <Link href="/shield" />


## `return someValue`

A common 

If we want to pass information we can use `return someValue` or `throw Abort(someValue)`.

If it is expected that our frontend calls telefunctions sometimes without the right permissions,
we `return` instead of `throw Abort()`.

```js
// *.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

export async function getTodoList() {
  const { user } = getContext()

  if (!user) {
    // It is expected that the user may not be logged in. We `return { isNotLoggedIn: true }`
    // instead of `throw Abort()`, so that the frontend can redirect the user to the login page.
    return { isNotLoggedIn: true }
  }

  // ...
}
```

## `throw Abort(someValue)`

