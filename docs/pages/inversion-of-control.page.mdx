TODO

```js
shield(findTodoItems, [{
  id: t.nullable(t.number),
  text: t.nullable(t.string),
  isCompleted: t.nullable(t.boolean),
  tags: t.array(t.string)
}])
// A generic function to retrieve to-do items
export async function findTodoItems({ id, text, isCompleted, tags }) {
  // Retrieve single to-do item
  if (id) {
    return Todo.findOne({ id })
  }
  // User can filter what to-do items are shown
  if (!text) {
    return Todo.findMany({ isCompleted, tags })
  }
  // User can search to-do items
  return Todo.search({ text }, { isCompleted, tags })
}
```

```js
// SearchComponent.telefunc.js


```

```js
// TodoListView.telefunc.js

shield(onTagRemove, [t.boolean, t.array(t.string)])
export async function getInitialData({ isCompleted, tags }) {
  const { userId } = getContext()
  const user = await User.findOne({ id: userId })
  const todoItems = await Todo.findMany({ isCompleted, tags })
  return {
    user,
    todoItems
  }
}
```


Note that we collocate:
 - `SearchComponent.telefunc.js` for `SearchComponent.jsx`.
 - `TodoListView.telefunc.js` for `TodoListView.jsx`.

There is a fundamental difference between REST/GraphQL and Telefunc:
 - With REST/GraphQL, it is the backend who determines and has the ownerhsip the strucute our API endpoints.
 - With Telefunc, it is the frontend who owns the telefunctions.

Our architecture will be drastically simpler if we always tailor each telefunction for one specific frontend event. For example:
 - A e-commerce product page needs the logged-in user first name, the product information, and the shopping cart status. We create *one* telefunction to provide the page with *all* it needs.
   ```js
   ```
 - A form is submitted.
   ```js

   ```
 that data  shop needs page  needs . This means that for each page load there is exactly one telefunction call.
 - In general, this means that best practice is 

That's why in Telefunc's world, the convention is to name telefunctions with the prefix 'on*` such as `onPageLoad` or `onFormSubmit`.



think in terms of "What does this frontend event
The reason being that Telefunc

In a classical , it is the backend who determines & controls the structure of the API.

With the Telefunc it's the other way around: it is the frontend who determines & controls telefunctions.



which makes reasoning about our app easier.

With REST/GraphQL we often have a tensions/conflicts between the backend who develops API but that doens't know what the frontend needs,
whereas with Telefunc there is a clear separation of concerns: the frontend owns telefunctions.

This

