import { Link } from 'libframe-docs/components'

> Alreay familiar with RPC? Only read the last sections:
> - [`shield()` & `Abort()`](#shield-abort)
> - [Inversion of Control](#inversion-of-control)
> - [TypeScript](#typescript)


## Hello World

Telefunc enables functions defined on the server-side to be called remotely from the browser-side.

```js
// hello.telefunc.js
// Environment: Node.js server

export { hello }

async function hello({ name }) {
  const message = 'Welcome ' + name
  return { message }
}
```

```html
<!-- index.html -->
<!-- Environment: Browser -->

<html>
  <body>
    <script type="module">
      // This import doesn't actually load the `hello.telefunc.js` file: Telefunc transforms
      // `hello.telefunc.js` into a thin HTTP client.
      import { hello } from './hello.telefunc.js'
      // This thin HTTP client makes an HTTP request when we call `hello()`
      const { message } = await hello({ name: 'Eva' })
      console.log(message) // Prints Eva
    </script>
  </body>
</html>
```

This practice of remotely calling functions is called *RPC* (Remote Procedure Call).


## ORM & SQL

Telefunc enables our frontend to use any SQL/ORM query, to fetch data:

```js
// todo.telefunc.js
// Environment: Node.js server

export { getTodoItems }

async function getTodoItems() {
  // With ORM
  const todoItems = Todo.findMany({ select: 'text' })

  // With SQL
  const todoItems = await execute("SELECT text FROM todo_items;")

  return todoItems
}
```

```jsx
// Environment: Browser

import { getTodoItems } from './todo.telefunc.js'

async function TodoList() {
  // Our frontend can use the Telefunction `getTodoItems()` to fetch data.
  const todoItems = await getTodoItems()
  return (
    <ul>{ todoItems.map(item =>
      <li>{ item.text }</li>
    )}</ul>
  )
}
```

> Note that,
> while we use JSX in our examples,
> Telefunc works with any UI framework (React, Vue, Svelte, ...).

And to mutate data:

```js
// todo.telefunc.js
// Environment: Node.js server

export { onNewTodo }

async function onNewTodo(text) {
  // ORM
  const todoItem = new Todo({ text })
  await todoItem.save()

  // SQL
  await execute(
    "INSERT INTO todo_items VALUES (:text)",
    { text }
  )
}
```

```jsx
// Environment: Browser

import { onNewTodo } from './todo.telefunc.js'

async function onClick(form) {
  const text = form.input.value
  await onNewTodo(text)
}

function CreateTodo() {
  return (
    <form>
      <input input="text"></input>
      <button onClick={onClick}>Add To-Do</button>
    </form>
  )
}
```

This means our frontend can directly tap into the power of our SQL/ORM engine. This is both simpler and more powerful than REST/GraphQL.

> We still need GraphQL or REST if a) we want third parties to access our database, or b) we want a decoupled frontend-backend deployment. See <Link href="/RPC-vs-GraphQL-REST" />.


## How it works

> Understanding the basic mechanics of Telefunc is paramount in order to properly protect our Telefunctions.

Let's see what happens when we call a Telefunction on the browser-side.

```js
// Environment: Browser

import { hello } from 'hello.telefunc.js'

const message = await hello('Eva')
```

The `hello.telefunc.js` file is never loaded in the browser.
Instead, Telefunc transforms `hello.telefunc.js` into the following.

```js
// hello.telefunc.js (after Telefunc transformation)
// Environement: Browser

import { __internal_makeHttpRequest } 'telefunc/client'

export const hello = (...args) => __internal_makeHttpRequest('/hello.telefunc.js:hello', args)
```

When we call `hello('Eva')` in the browser-side, the following happens:
 1. The `__internal_makeHttpRequest()` function makes an HTTP request.
    ```
    POST /_telefunc HTTP/1.1
    {
      "path": "/hello.telefunc.js:hello",
      "args": [{"name": "Eva"}]
    }
    ```
 2. Our Telefunc server middleware
    ```js
    // server.js
    import { createTelefunc } from 'telefunc'

    // Server middleware (Express.js/Fastify/Koa/Hapi/...)
    const { telefunc } = createTelefunc()
    app.use('/_telefunc', async (req, res) => {
      const httpResponse = await telefunc(req)
      res.send(httpResponse.body)
    })
    ```
    replies following HTTP response:
    ```
    HTTP/1.1 200 OK
    {
      "telefunctionResult": {
        "message": "Welcome Eva"
      }
    }
    ```

In other words, the browser-side remotely calls our `hello()` function which is always executed on the server-side.


## Telefunctions need protection

Our telefunctions can be accessed remotely not only from our frontend but really from anyone.

Anyone can open a terminal and make an HTTP request.

```bash
curl
 -d '{
   "path": "/hello.telefunc.js:hello",
   "args": [{"name": "Alice"}]
 }'
 https://our-website.com/_telefunc
```

Therefore, the following is a bad idea.

```js
// run.telefunc.js
// Environment: Node.js

export { run }

async function run(sql) {
  return await database.execute(sql)
}
```

As anyone can do an HTTP request like the following.

```bash
curl
 -d '{
   "telefunctionPath": "/run.telefunc.js:run",
   "telefunctionArguments": ["SELECT login, password FROM users;"]
  }'
  https://our-website.com/_telefunc
```

This means our Telefunctions are essentially public and we need to protect them, which we can do with Telefunc's `shield()` and `Abort()`.

## `shield()` & `Abort()`

As we've seen in the previous section,
the following Telefunction is not safe.

```js
// run.telefunc.js
// Environment: Node.js

export { run }

async function run(sql) {
  return await database.execute(sql)
}
```

But we can use `Abort()` to protect it:

```js
// run.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

export { run }

async function run(sql) {
  // We talk about `getContext()` in the following section "Authentication"
  const ctx = getContext()
  const { user } = ctx

  // Only Admins can run this telefunction
  if (user.isAdmin !== true) {
    throw new Abort()
  }

  return await database.execute(sql)
}
```

Also, Telefunc's `shield()` allow us to ensure argument types:

```js
// onNewTodo.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

shield(onNewTodo, [t.string])
export async function onNewTodo(text) {
  // `shield()` ensures that `text` will always be `typeof text === 'string'`
  /* ... */
}
```

## Authentication

Telefunc's `setContext()` and `getContext()` allows to provide contextual information to our telefunctions,
such as information about the logged-in user.

```js
// server.js
import { setContext } from 'telefunc'

// Server middleware
app.use('*', async (req, res) => {
  // Authentication middlewares (e.g. Passport.js or Grant) provide information
  // about the logged-in user on the `req` object.
  const user = req.user

  // Or when using a third-party authentication provider (e.g. Auth0):
  const user = await authProviderApi.getUser(req.headers)

  // We make `user` available to our telefunctions
  setContext({ user })
})
```

```js
// todo.telefunc.js
// Environment: Node.js server

import { getContext } from 'telefunc'

export { getTodoItems }

async function getTodoItems() {
  const { user } = getContext()

  const authorId = user.id

  // With ORM
  const todoItems = Todo.findMany({ select: 'text', authorId })

  // With SQL
  const todoItems = await execute(
    "SELECT text FROM todo_items;",
    { authorId }
  )

  return todoItems
}
```

More at <Link href="/permissions" />.

## Inversion of control

Coming from the REST/GraphQL world, we may be tempted to implement generic Telefunctions.

```js
// todo.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

shield(updateTodoItem, [t.number, t.string, t.boolean, t.array(t.string)])
// A generic function to mutate to-do items
export async function updateTodoItem(id, text, isCompleted, tags) {
  const todoItem = Todo.findOne({ id })
  todoItem.text = text
  todoItem.isCompleted = isCompleted
  todoItem.tags = tags
  await todoItem.save()
}

shield(findTodoItems, [{
  id: t.nullable(t.number),
  text: t.nullable(t.string),
  isCompleted: t.nullable(t.boolean),
  tags: t.array(t.string)
}])
// A generic function to retrieve to-do items
export async function findTodoItems({ id, text, isCompleted, tags }) {
  // Retrieve single to-do item
  if (id) {
    return Todo.findOne({ id })
  }
  // User can filter what to-do items are shown
  if (!text) {
    return Todo.findMany({ isCompleted, tags })
  }
  // User can search to-do items
  return Todo.search({ text }, { isCompleted, tags })
}
```

But this is not idiomatic for Telefunc.
With Telefunc, if we define telefunctions tailored to the needs of the frontend instead.

```js
// SearchComponent.telefunc.js


```

```js
// TodoListView.telefunc.js

shield(onTagRemove, [t.boolean, t.array(t.string)])
export async function getInitialData({ isCompleted, tags }) {
  const { userId } = getContext()
  const user = await User.findOne({ id: userId })
  const todoItems = await Todo.findMany({ isCompleted, tags })
  return {
    user,
    todoItems
  }
}
```

```js
// TodoItem.telefunc.js

shield(onTagRemove, [t.number, t.string])
export async function onTagRemove(id, tag) {
  const todoItem = Todo.findOne({ id })
  todoItem.tags = todoItem.tags.filter(t => t !== tag)
  await todoItem.save()
}

shield(onTagRemove, [t.number, t.string])
export async function onTagAdd(id, tag) {
  const todoItem = Todo.findOne({ id })
  todoItem.tags = [...todoItem.tags, tag]
  await todoItem.save()
}

shield(onTagRemove, [t.number, t.string])
export async function onTextChange(id, text) {
  const todoItem = Todo.findOne({ id })
  todoItem.text = text
  await todoItem.save()
}

shield(onTagRemove, [t.number, t.string])
export async function onCompleteToggle(id) {
  const todoItem = Todo.findOne({ id })
  todoItem.isCompleted = !todoItem.isCompleted
  await todoItem.save()
}
```

Note that we collocate:
 - `SearchComponent.telefunc.js` for `SearchComponent.jsx`.
 - `TodoListView.telefunc.js` for `TodoListView.jsx`.

There is a fundamental difference between REST/GraphQL and Telefunc:
 - With REST/GraphQL, it is the backend who determines and has the ownerhsip the strucute our API endpoints.
 - With Telefunc, it is the frontend who owns the telefunctions.

Our architecture will be drastically simpler if we always tailor each telefunction for one specific frontend event. For example:
 - A e-commerce product page needs the logged-in user first name, the product information, and the shopping cart status. We create *one* telefunction to provide the page with *all* it needs.
   ```js
   ```
 - A form is submitted.
   ```js

   ```
 that data  shop needs page  needs . This means that for each page load there is exactly one telefunction call.
 - In general, this means that best practice is 

That's why in Telefunc's world, the convention is to name telefunctions with the prefix 'on*` such as `onPageLoad` or `onFormSubmit`.



think in terms of "What does this frontend event
The reason being that Telefunc

In a classical , it is the backend who determines & controls the structure of the API.

With the Telefunc it's the other way around: it is the frontend who determines & controls telefunctions.

## TypeScript

Telefunc works with TypeScript out-of-the-box.

```ts
// UserSettings.telefunc.js
// Environment: Node.js server

import { shield } from 'telefunc'
const t = shield.type

export { onUserSettingsChange }

shield(onUserSettingsChange, [
  t.union(
    { name: t.value('firstName'), newVal: t.string },
    { name: t.value('age'), newVal: t.number },
  )
)
async function onUserSettingChange({ name, newVal }) {
  if (name === 'firstName') {
    // Note that `shield()` infers `onUserSettingsChange`'s arguments.
    // This means that TypeScript knows that `newVal` is a string here.
    newVal++ // TypeScript will complain
  }
  if (name === 'age') {
    // TypeScript knows that `newVal` is a number here.
    newVal++ // TypeScript won't complain
  }
}
```

```tsx
// UserSettings.jsx
// Environment: Browser

// The trick is that TypeScript believes that `UserSettings.telefunc.js` is imported.
// This means that `onUserSettingChange()` as exactly the type we defined.
import { onUserSettingChange } from './UserSettings.telefunc.js'

function UserSettings() {
  return (
    <form>
      <input
        input="text"
        onChange={ev =>
          // TypeScript will complain if `ev.target.value` is not a string
          onUserSettingChange('firstName', ev.target.value)
        }
      >
        {initialState.firstName}
      </input>
      <input
        input="number"
        onChange={ev =>
          // TypeScript will complain if `ev.target.value` is not a number
          onUserSettingChange('age', ev.target.value)
        }
      >
        {initialState.age}
      </input>
    </form>
  )
}
```

More at <Link href="/typescript" />.
