import { Link } from 'libframe-docs/components'

> Alreay familiar with RPC? Only read the last sections:
> - [`shield()` & `Abort()`](#shield-abort)
> - [Authentication](#authentication)
> - [Inversion of Control](#inversion-of-control)
> - [TypeScript](#typescript)


## Hello World

Telefunc enables functions defined on the server-side to be called remotely from the browser-side.

```js
// hello.telefunc.js
// Environment: Node.js server

export { hello }

async function hello({ name }) {
  const message = 'Welcome ' + name
  return { message }
}
```

```html
<!-- index.html -->
<!-- Environment: Browser -->

<html>
  <body>
    <script type="module">
      // This import doesn't actually load the `hello.telefunc.js` file: Telefunc transforms
      // `hello.telefunc.js` into a thin HTTP client.
      import { hello } from './hello.telefunc.js'
      // This thin HTTP client makes an HTTP request when we call `hello()`
      const { message } = await hello({ name: 'Eva' })
      console.log(message) // Prints Eva
    </script>
  </body>
</html>
```

This practice of remotely calling functions is called *RPC* (Remote Procedure Call).


## ORM & SQL

Telefunc enables our frontend to use any SQL/ORM query, to fetch data:

```js
// todo.telefunc.js
// Environment: Node.js server

export { getTodoItems }

async function getTodoItems() {
  // With ORM
  const todoItems = Todo.findMany({ select: 'text' })

  // With SQL
  const todoItems = await execute("SELECT text FROM todo_items;")

  return todoItems
}
```

```jsx
// Environment: Browser

import { getTodoItems } from './todo.telefunc.js'

async function TodoList() {
  // Our frontend can use the Telefunction `getTodoItems()` to fetch data.
  const todoItems = await getTodoItems()
  return (
    <ul>{ todoItems.map(item =>
      <li>{ item.text }</li>
    )}</ul>
  )
}
```

> Note that,
> while we use JSX in our examples,
> Telefunc works with any UI framework (React, Vue, Svelte, ...).

And to mutate data:

```js
// todo.telefunc.js
// Environment: Node.js server

export { onNewTodo }

async function onNewTodo(text) {
  // ORM
  const todoItem = new Todo({ text })
  await todoItem.save()

  // SQL
  await execute(
    "INSERT INTO todo_items VALUES (:text)",
    { text }
  )
}
```

```jsx
// Environment: Browser

import { onNewTodo } from './todo.telefunc.js'

async function onClick(form) {
  const text = form.input.value
  await onNewTodo(text)
}

function CreateTodo() {
  return (
    <form>
      <input input="text"></input>
      <button onClick={onClick}>Add To-Do</button>
    </form>
  )
}
```

This means our frontend can directly tap into the power of our SQL/ORM engine. This is both simpler and more powerful than REST/GraphQL.

> We still need GraphQL or REST if a) we want third parties to access our database, or b) we want a decoupled frontend-backend deployment. See <Link href="/RPC-vs-GraphQL-REST" />.


## How it works

> Understanding the basic mechanics of Telefunc is paramount in order to properly protect our Telefunctions.

Let's see what happens when we call a Telefunction on the browser-side.

```js
// Environment: Browser

import { hello } from 'hello.telefunc.js'

const message = await hello('Eva')
```

The `hello.telefunc.js` file is never loaded in the browser.
Instead, Telefunc transforms `hello.telefunc.js` into the following.

```js
// hello.telefunc.js (after Telefunc transformation)
// Environement: Browser

import { __internal_makeHttpRequest } 'telefunc/client'

export const hello = (...args) => __internal_makeHttpRequest('/hello.telefunc.js:hello', args)
```

When we call `hello('Eva')` in the browser-side, the following happens:
 1. The `__internal_makeHttpRequest()` function makes an HTTP request.
    ```
    POST /_telefunc HTTP/1.1
    {
      "path": "/hello.telefunc.js:hello",
      "args": [{"name": "Eva"}]
    }
    ```
 2. Our Telefunc server middleware
    ```js
    // server.js
    import { createTelefunc } from 'telefunc'

    // Server middleware (Express.js/Fastify/Koa/Hapi/...)
    const { telefunc } = createTelefunc()
    app.use('/_telefunc', async (req, res) => {
      const httpResponse = await telefunc(req)
      res.send(httpResponse.body)
    })
    ```
    replies following HTTP response:
    ```
    HTTP/1.1 200 OK
    {
      "telefunctionResult": {
        "message": "Welcome Eva"
      }
    }
    ```

In other words, the browser-side remotely calls our `hello()` function which is always executed on the server-side.


## Telefunctions need protection

Our telefunctions can be accessed remotely not only from our frontend but really from anyone.

Anyone can open a terminal and make an HTTP request.

```bash
curl
 -d '{
   "path": "/hello.telefunc.js:hello",
   "args": [{"name": "Alice"}]
 }'
 https://our-website.com/_telefunc
```

Therefore, the following is not safe.

```js
// run.telefunc.js
// Environment: Node.js

export { run }

async function run(sql) {
  return await database.execute(sql)
}
```

As anyone can do an HTTP request like the following.

```bash
curl
 -d '{
   "telefunctionPath": "/run.telefunc.js:run",
   "telefunctionArguments": ["SELECT login, password FROM users;"]
  }'
  https://our-website.com/_telefunc
```

This means our Telefunctions are essentially public and we need to protect them, which we can do with Telefunc's `shield()` and `Abort()`.

## `shield()` & `Abort()`

As we've seen in the previous section,
the following Telefunction is not safe.

```js
// run.telefunc.js
// Environment: Node.js

export { run }

async function run(sql) {
  return await database.execute(sql)
}
```

But we can use `Abort()` to protect it:

```js
// run.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

export { run }

async function run(sql) {
  // We talk about `getContext()` in the following section "Authentication"
  const ctx = getContext()
  const { user } = ctx

  // Only Admins can run this telefunction
  if (user.isAdmin !== true) {
    throw new Abort()
  }

  return await database.execute(sql)
}
```

Also, Telefunc's `shield()` allow us to ensure argument types:

```js
// onNewTodo.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

shield(onNewTodo, [t.string])
export async function onNewTodo(text) {
  // `shield()` ensures that `text` will always be `typeof text === 'string'`
  /* ... */
}
```

## Authentication

Telefunc's `setContext()` and `getContext()` allows to provide contextual information to our telefunctions,
such as information about the logged-in user.

```js
// server.js
import { setContext } from 'telefunc'

// Server middleware
app.use('*', async (req, res) => {
  // Authentication middlewares (e.g. Passport.js or Grant) provide information
  // about the logged-in user on the `req` object.
  const user = req.user

  // Or when using a third-party authentication provider (e.g. Auth0):
  const user = await authProviderApi.getUser(req.headers)

  // We make `user` available to our telefunctions
  setContext({ user })
})
```

```js
// todo.telefunc.js
// Environment: Node.js server

import { getContext } from 'telefunc'

export { getTodoItems }

async function getTodoItems() {
  const { user } = getContext()

  const authorId = user.id

  // With ORM
  const todoItems = Todo.findMany({ select: 'text', authorId })

  // With SQL
  const todoItems = await execute(
    "SELECT text FROM todo_items;",
    { authorId }
  )

  return todoItems
}
```

More at <Link href="/permissions" />.

## Inversion of control

Coming from the REST/GraphQL world, we may be tempted to implement generic Telefunctions.

```js
// todo.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

// Generic telefunctions about the data model `Todo`.

shield(getTodoItems, [t.boolean])
export async function getTodoItems(isCompleted) {
  const todoItems = Todo.findMany({ isCompleted })
  return todoItems
}

shield(updateTodoItem, [t.number, t.string, t.boolean])
export async function updateTodoItem(id, text, isCompleted) {
  const todoItem = Todo.findOne({ id })
  todoItem.text = text
  todoItem.isCompleted = isCompleted
  await todoItem.save()
}
```

```js
// user.telefunc.js

import { getContext } from 'telefunc'

// Generic telefunctions about the data model `User`.

export function getUserData() {
  const { user } = getContext()
  // All data that the frontend may need
  const { firstName, lastName, age/*, ...*/ } = user
  return { firstName, lastName, age/*, ...*/ }
}
```

But this is not idiomatic for Telefunc.
With Telefunc, we define telefunctions tailored to frontend components instead.

```js
// TodoList.telefunc.js

// This file provides the telefunctions that `TodoList.jsx` needs.

import { getContext } from 'telefunc'

export { getInitialData }

// This returns exactly what `TodoList` needs.
async function getInitialData() {
  const { user } = getContext()

  // `TodoList.jsx` only shows non-completed to-dos.
  const todoItems = await Todo.findMany({ isCompleted: false })

  // `TodoList.jsx` only needs `firstName`
  const { firstName } = user

  return {
    user: { firstName },
    todoItems
  }
}
```

```js
// UserProfile.telefunc.js

// Telefunctions for `UserProfile.jsx`.

import { getContext } from 'telefunc'

export { getInitialData }

export async function getInitialData() {
  const { user } = getContext()
  // `UserProfile.jsx` needs all user data.
  const userProfile = { ...user }
  delete userProfile.password
  return { userProfile }
}
```

```js
// TodoItem.telefunc.js

// One telefunction per <TodoItem /> event

shield(onTextChange, [t.number, t.string])
export async function onTextChange(id, text) {
  const todoItem = Todo.findOne({ id })
  todoItem.text = text
  await todoItem.save()
}

shield(onCompleteToggle, [t.number, t.string])
export async function onCompleteToggle(id) {
  const todoItem = Todo.findOne({ id })
  todoItem.isCompleted = !todoItem.isCompleted
  await todoItem.save()
}
```

The telefunctions in `TodoItem.telefunc.js` are determined by `TodoItem.jsx`;
it is the frontend developer/development that owns the telefunctions.

This is the opposite of GraphQL/REST where is the the backend developer/development that owns the GraphQL/RESTful API.

This inversion of control leads to a clearer seperation of concerns.

More at <Link href="/inversion-of-control" />.

## TypeScript

Telefunc works with TypeScript out-of-the-box.

```ts
// UserSettings.telefunc.js
// Environment: Node.js server

import { shield } from 'telefunc'
const t = shield.type

export { onUserSettingsChange }

shield(onUserSettingsChange, [
  t.union(
    { name: t.value('firstName'), newVal: t.string },
    { name: t.value('age'), newVal: t.number },
  )
)
async function onUserSettingChange({ name, newVal }) {
  if (name === 'firstName') {
    // Note that `shield()` infers `onUserSettingsChange`'s type.
    // This means that TypeScript knows that `newVal` is a string here.
    newVal++ // TypeScript will complain
  }
  if (name === 'age') {
    // TypeScript knows that `newVal` is a number here.
    newVal++ // TypeScript won't complain
  }
}
```

```tsx
// UserSettings.jsx
// Environment: Browser

// TypeScript believes that `UserSettings.telefunc.js` is imported. This
// means that `onUserSettingChange()` has exactly the type we defined.
import { onUserSettingChange } from './UserSettings.telefunc.js'

function UserSettings() {
  return (
    <form>
      <input
        input="text"
        onChange={ev =>
          // TypeScript will complain if `ev.target.value` is not a string
          onUserSettingChange('firstName', ev.target.value)
        }
      >
        {initialState.firstName}
      </input>
      <input
        input="number"
        onChange={ev =>
          // TypeScript will complain if `ev.target.value` is not a number
          onUserSettingChange('age', ev.target.value)
        }
      >
        {initialState.age}
      </input>
    </form>
  )
}
```

More at <Link href="/typescript" />.
