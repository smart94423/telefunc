import { Link } from 'libframe-docs/components'

> Alreay familiar with RPC? Only read the last sections:
> - [`shield()` & `Abort()`](#shield-abort)
> - [Authentication](#authentication)
> - [Inversion of Control](#inversion-of-control)
> - [TypeScript](#typescript)


## Hello World

Telefunc enables functions defined on the server-side to be called remotely from the browser-side.

```js
// hello.telefunc.js
// Environment: Node.js

export { hello }

async function hello({ name }) {
  const message = 'Welcome ' + name
  return { message }
}
```

```html
<!-- index.html -->
<!-- Environment: Browser -->

<html>
  <body>
    <script type="module">
      // This import doesn't actually load the `hello.telefunc.js` file: Telefunc transforms
      // `hello.telefunc.js` into a thin HTTP client.
      import { hello } from './hello.telefunc.js'
      // This thin HTTP client makes an HTTP request when we call `hello()`
      const { message } = await hello({ name: 'Eva' })
      console.log(message) // Prints 'Welcome Eva'
    </script>
  </body>
</html>
```

Telefunctions such as `hello()` always run on the server-side.

> This practice of calling functions remotely is called *RPC* (Remote Procedure Call).


## ORM & SQL

Because they are always run on the server-side,
telefunctions are able to run SQL/ORM queries.

This, in essence, enables our frontend to use SQL/ORM queries.

```js
// TodoList.telefunc.js
// Environment: Node.js

export { getTodoItems }

async function getTodoItems() {
  // ORM
  const todoItems = await Todo.findMany({ select: 'text' })
  // SQL
  const todoItems = await execute("SELECT text FROM todo_items;")

  return todoItems
}
```

```jsx
// TodoList.jsx
// Environment: Browser

import { getTodoItems } from './TodoList.telefunc.js'

async function TodoList() {
  // Our frontend uses the telefunction `getTodoItems()` to execute a SQL/ORM query that
  // retrieves the data it needs.
  const todoItems = await getTodoItems()
  return (
    <ul>{ todoItems.map(item =>
      <li>{ item.text }</li>
    )}</ul>
  )
}
```

> Note how we collocate and name `TodoList.telefunc.js` after `TodoList.jsx`; it's a practice we'll talk about later.

> Our examples uses JSX
> but note that Telefunc works with any UI framework (React, Vue, Svelte, ...).

Our frontend can also use telefunctions to mutate data.

```js
// CreateTodo.telefunc.js
// Environment: Node.js

export { onNewTodo }

async function onNewTodo(text) {
  // ORM
  const todoItem = new Todo({ text })
  await todoItem.save()

  // SQL
  await execute(
    "INSERT INTO todo_items VALUES (:text)",
    { text }
  )
}
```

> This `onNewTodo` telefunction is missing a `shield(onNewTodo, [t.string])` protection, which we'll talk about in a moment.

```jsx
// CreateTodo.jsx
// Environment: Browser

import { onNewTodo } from './CreateTodo.telefunc.js'

async function onClick(form) {
  const text = form.input.value
  await onNewTodo(text)
}

function CreateTodo() {
  return (
    <form>
      <input input="text"></input>
      <button onClick={onClick}>Add To-Do</button>
    </form>
  )
}
```

This means our frontend can directly tap into the power of our SQL/ORM engine. This is both simpler and more powerful than REST/GraphQL.

> We need a GraphQL/RESTful API if, and only if:
>  - There are third party frontends/clients that need to be able to access our database.
>  - Or we need to be able to deploy our frontend and backend independently of each other.
>
> Otherwise RPC/Telefunc is simpler and more powerful.
> More at <Link href="/RPC-vs-GraphQL-REST" />.


## How it works

> Understanding the basic mechanics of Telefunc is paramount in order to properly use Telefunc.

Let's see what happens when we call a telefunction in the browser.

```js
// Environment: Browser

import { hello } from './hello.telefunc.js'

const message = await hello('Eva')
```

The `hello.telefunc.js` file is never loaded in the browser:
Telefunc transforms `hello.telefunc.js` into the following:

```js
// hello.telefunc.js (after Telefunc transformation)
// Environement: Browser
import { __internal_makeHttpRequest } 'telefunc/client'
export const hello = (...args) => __internal_makeHttpRequest('/hello.telefunc.js:hello', args)
```

So, when we call `hello('Eva')` in the browser-side, the following happens:
 1. On the browser-side, the `__internal_makeHttpRequest()` function makes an HTTP request to our server.
    ```
    POST /_telefunc HTTP/1.1
    {
      "path": "/hello.telefunc.js:hello",
      "args": [{"name": "Eva"}]
    }
    ```
 2. On the server-side, our Telefunc middleware:
    ```js
    // server.js
    import { createTelefunc } from 'telefunc'

    // Server middleware (Express.js/Fastify/Koa/Hapi/...)
    const { telefunc } = createTelefunc()
    app.use('/_telefunc', async (req, res) => {
      const httpResponse = await telefunc(req)
      res.send(httpResponse.body)
    })
    ```
    Replies following HTTP response:
    ```
    HTTP/1.1 200 OK
    {
      "return": {
        "message": "Welcome Eva"
      }
    }
    ```

In other words,
the `hello()` function is always executed on the server-side,
and the browser-side remotely calls `hello()` by using an HTTP request.


## Telefunctions need protection

Our telefunctions can be remotely called not only by our frontend but also by anyone.

Anyone can open a terminal and make an HTTP request:

```bash
curl https://our-website.com/_telefunc --data '{
   "path": "/hello.telefunc.js:hello",
   "args": [{"name": "Alice"}]
 }'
```

Thus, this telefunction is problematic:

```js
// run.telefunc.js
// Environment: Node.js

export { run }

async function run(sql) {
  return await database.execute(sql)
}
```

Because anyone can make this HTTP request:

```bash
curl https://our-website.com/_telefunc --data '{
    "path": "/run.telefunc.js:run",
    "args": ["SELECT login, password FROM users;"]
  }'
```

In a nuthsell: telefunctions are public and need protection.

## `shield()` & `Abort()`

As we've seen in the previous section,
the following telefunction is problematic.

```js
// run.telefunc.js
// Environment: Node.js

export { run }

async function run(sql) {
  return await database.execute(sql)
}
```

But we can use `Abort()` to protect it:

```js
// run.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

export { run }

async function run(sql) {
  // We'll talk about `getContext()` later
  const { user } = getContext()

  // Only Admins are allowed to run this telefunction
  if (user.isAdmin !== true) {
    throw Abort()
  }

  return await database.execute(sql)
}
```

Also, since telefunctions are public and can be called by anyone, we cannot assuming anything about the arguments type.
We could use `Abort()` again:

```js
// CreateTodo.telefunc.js
// Environment: Node.js

export async function onNewTodo(text) {
  // Since `onNewTodo` can be called by anyone, `text` can be any value.

  // We make sure that `text` is a string
  if (typeof text !== 'string') {
    throw Abort()
  }

  // We can now safely assume `text` to be a string
  const todoItem = new Todo({ text })

  /* ...*/
}
```

But for more complex arguments, `Abort()` is cumbersome:

```js
// CreateTodo.telefunc.js
// Environment: Node.js

export async function onNewTodo(args) {
  if (
    args?.constructor !== Object ||
    typeof args.text !== 'string' ||
    typeof args.isCompleted !== 'boolean'
  ) {
    throw Abort()
  }
  const { text, isCompleted } = args
  /* ... */
}
```

We can use `shield()` instead:

```js
// CreateTodo.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

shield(onNewTodo, [{text: t.string, isCompleted: t.boolean}])
export async function onNewTodo({ text, isCompleted }) {
  /* ... */
}
```

Not only does `shield()` call `new Abort()` on our behalf, but it also infers the arguments type for TypeScript and IntelliSense.

## Authentication

Telefunctions often need context: is the user logged-in? What is the user's ID? Etc.

We use `setContext()` and `getContext()` to provide contextual information to our telefunctions.

```js
// server.js
// Environment: Node.js

import { setContext } from 'telefunc'

// Server middleware (Express.js/Fastify/Koa/Hapi/...)
app.use('*', async (req, res) => {
  // Authentication middlewares (e.g. Passport.js or Grant) usually make information
  // about the logged-in user available at `req.user`.
  const user = req.user

  // We make `user` available to our telefunctions
  setContext({ user })
})
```

```js
// TodoList.telefunc.js
// Environment: Node.js

import { getContext } from 'telefunc'

export { getTodoItems }

async function getTodoItems() {
  // We can access `user` here
  const { user } = getContext()

  // For example, we can use `user.id` to find all to-do items of the logged-in user
  const authorId = user.id
  const todoItems = await Todo.findMany({ select: 'text', authorId })
  return todoItems
}
```

## Inversion of control

Coming from the REST/GraphQL world, we may be tempted to implement generic telefunctions.

```js
// todo.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

// Generic telefunctions about the data model `Todo`.

shield(getTodoItems, [t.boolean])
export async function getTodoItems(isCompleted) {
  const todoItems = await Todo.findMany({ isCompleted })
  return todoItems
}

shield(updateTodoItem, [t.number, t.string, t.boolean])
export async function updateTodoItem(id, text, isCompleted) {
  const todoItem = await Todo.findOne({ id })
  todoItem.text = text
  todoItem.isCompleted = isCompleted
  await todoItem.save()
}
```

```js
// user.telefunc.js

import { getContext } from 'telefunc'

// Generic telefunctions about the data model `User`.

export function getUserData() {
  const { user } = getContext()
  // All data that the frontend may need
  const { firstName, lastName, age, country/*, ...*/ } = user
  return { firstName, lastName, age, country/*, ...*/ }
}
```

But this is not Telefunc idiomatic;
we usually define telefunctions tailored to frontend components.

```js
// TodoList.telefunc.js

// This file provides the telefunctions that `TodoList.jsx` needs.

import { getContext } from 'telefunc'

export { getInitialData }

// This returns *exactly* what `<TodoList>` needs.
async function getInitialData() {
  const { user } = getContext()

  // `<TodoList>` only shows non-completed to-dos.
  const todoItems = await Todo.findMany({ isCompleted: false })

  // `<TodoList>` only shows `user.firstName`
  const { firstName } = user

  return {
    user: { firstName },
    todoItems
  }
}
```

```js
// UserProfile.telefunc.js

// Telefunctions for `UserProfile.jsx`.

import { getContext } from 'telefunc'

export { getInitialData }

export async function getInitialData() {
  const ctx = getContext()
  // `<UserProfile>` shows all user data.
  const user = { ...ctx.user }
  delete user.password
  return { user }
}
```

```js
// TodoItem.telefunc.js

import { shield } from 'telefunc'
const t = shield.type

// Common Telefunc practice: we create one telefunction per user event.

// When the user modifies the text of a to-do item
shield(onTextChange, [t.number, t.string])
export async function onTextChange(id, text) {
  const todoItem = await Todo.findOne({ id })
  todoItem.text = text
  await todoItem.save()
}

// When the user clicks on the is-completed checkbox
shield(onCompleteToggle, [t.number, t.string])
export async function onCompleteToggle(id) {
  const todoItem = await Todo.findOne({ id })
  todoItem.isCompleted = !todoItem.isCompleted
  await todoItem.save()
}
```

The telefunctions of `TodoItem.telefunc.js` are determined by the needs of `TodoItem.jsx`;
it is the frontend development/developer that owns telefunctions.

This is the opposite of GraphQL/REST where it is the backend development/developer that owns the GraphQL/RESTful API.

This inversion of control leads to a fundamentally improved separation of concerns.

## TypeScript

`shield()` infers the arguments type:

```ts
// UserSettings.telefunc.js
// Environment: Node.js

import { shield } from 'telefunc'
const t = shield.type

shield(onUserSettingsChange, [
  t.union(
    { name: t.value('firstName'), newVal: t.string },
    { name: t.value('age'), newVal: t.number }
  )
])
export async function onUserSettingChange({ name, newVal }) {
  if (name === 'firstName') {
    // `shield()` infers `onUserSettingsChange`'s arguments type:
    // TypeScript knows that `newVal` is a string in this if-block.
    newVal++ // ❌ TypeScript complains that `newVal` is not a number.
  }
  if (name === 'age') {
    // TypeScript knows that `newVal` is a number in this if-block.
    newVal++ // ✅
  }
}
```

Our frontend seamlessly uses our backend telefunctions's type:

```tsx
// UserSettings.jsx
// Environment: Browser

// TypeScript believes that `UserSettings.telefunc.js` is imported. This means that TypeScript
// works out-of-the-box; type-safety & IntelliSense just works (including auto-import!).
import { onUserSettingChange } from './UserSettings.telefunc.js'

function UserSettings() {
  return (
    <form>
      <input
        input="text"
        onChange={ev =>
          // TypeScript complains if `ev.target.value` is not a string
          onUserSettingChange('firstName', ev.target.value)
        }
      >
        {initialState.firstName}
      </input>
      <input
        input="number"
        onChange={ev =>
          // TypeScript complains if `ev.target.value` is not a number
          onUserSettingChange('age', ev.target.value)
        }
      >
        {initialState.age}
      </input>
    </form>
  )
}
```
