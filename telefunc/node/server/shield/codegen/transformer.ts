export { generateShield, replaceShieldTypeAlias }

import { readFileSync } from 'fs'
import { Project, VariableDeclarationKind } from 'ts-morph'
import { assert, assertWarning } from '../../../utils'

const typesSrc = readTypesFile()
assert(typesSrc.includes('SimpleType'))

const tAlias = '__shieldGenerator_t' // alias for shield.t

const replaceShieldTypeAlias = (shieldStr: string): string =>
  shieldStr.replace(/(?<!t.const\('(?!'\)).*)t\./g, `${tAlias}.`)

const shieldName = (telefunctionName: string): string => `${telefunctionName}Shield`

function generateShield(telefuncFileCode: string): string {
  const project = new Project({
    compilerOptions: {
      strict: true
    }
  })

  project.createSourceFile('types.ts', typesSrc)
  const telefuncFileSource = project.createSourceFile('telefunc.ts', telefuncFileCode)

  // This source file is used for evaluating the template literal types' values
  const shieldStrSource = project.createSourceFile('shield-str.ts')
  shieldStrSource.addImportDeclaration({
    moduleSpecifier: './types',
    namedImports: ['ShieldArrStr']
  })

  const telefunctions = telefuncFileSource.getFunctions().filter((f) => f.isExported())
  const telefunctionNames = telefunctions.flatMap((telefunction) => {
    const name = telefunction.getName()
    if (!name) return []
    return [name]
  })
  shieldStrSource.addImportDeclaration({
    moduleSpecifier: './telefunc',
    namedImports: telefunctionNames
  })

  // assign the template literal type to a string
  // then diagnostics are used to get the value of the template literal type
  for (const telefunctionName of telefunctionNames) {
    shieldStrSource.addTypeAlias({
      name: shieldName(telefunctionName),
      type: `ShieldArrStr<Parameters<typeof ${telefunctionName}>>`
    })
  }

  const shieldAlias = '__shieldGenerator_shield' // alias for shield
  telefuncFileSource.addImportDeclaration({
    moduleSpecifier: 'telefunc',
    namedImports: [
      {
        name: 'shield',
        alias: shieldAlias
      }
    ]
  })
  telefuncFileSource.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [
      {
        name: tAlias,
        initializer: `${shieldAlias}.type`
      }
    ]
  })

  for (const telefunctionName of telefunctionNames) {
    const typeAliasName = shieldName(telefunctionName)
    const typeAlias = shieldStrSource.getTypeAlias(typeAliasName)
    assert(typeAlias, `Failed to get type alias \`${typeAliasName}\`.`)

    const shieldStr = typeAlias.getType().getLiteralValue()

    if (!shieldStr || typeof shieldStr !== 'string') {
      assertWarning(false, `Failed to generate shield() for telefunction ${telefunctionName}()`, { onlyOnce: true })
      continue
    }
    const shieldStrWithAlias = replaceShieldTypeAlias(shieldStr)
    telefuncFileSource.addStatements(
      `${shieldAlias}(${telefunctionName}, ${shieldStrWithAlias}, { __autoGenerated: true })`
    )
  }

  const shieldCode = telefuncFileSource.getText()
  return shieldCode
}

function readTypesFile() {
  try {
    // For build `dist/`
    return readFileSync(`${__dirname}/types.d.ts`).toString()
  } catch {
    // For Vitest
    return readFileSync(`${__dirname}/types.ts`).toString()
  }
}
